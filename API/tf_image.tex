\section{tf.image}
\subsection{adjust\_brightness}
\begin{lstlisting}[language=Python]
adjust_brightness(
image,
delta)
\end{lstlisting}
调整灰度或者RGB图像的亮度。

这是一个方便的转换RGB到浮点表达，调整亮度，然后转换它回原始的数据类型。如果一些调整是限制的它适当的最小化多余转化。delta的值被增加到tensor类型的image的所有组件，不经image和delta在添加（image被放大，如果它是固定点表达的化）前被转化为float。对于通常的图像，delta应该在[0,1)之间，正如浮点表达式被添加到图像上，这里像素值在[0,1)之间。

参数:
\begin{itemize}
		\item image:一个tensor
		\item delta:一个标量，添加上的像素值
		\item [Returns]:和image类型和形状相同的亮度调整
\end{itemize}
\subsection{adjust\_contrast}
\lstinline[language=Python]{adjust_contrast(images,contrast_factor)}
调整RGB或者灰度图像的对比度。

这是一个方便的转换RGB图像到浮点表达，调整他的对比度然后转化回原始的数据类型。如果一些调整是限制的它明智的最小化多余转化，image是一个至少3维的tensor。三维解释为[height,width,channels],另一个维度表示是一个图像集合，像[batch,height,width,channels]

对比度调整依赖于每个图像的通道，对每个通道Op计算通道中图像像素的均值然后调整每个组件x为$(x-mean)*contrast_factor+mean$
参数:
\begin{itemize}
		\item images:需要调整的图像，至少是3维
		\item contrast\_factor:一个调整对比度的浮点数
		\item[Returns]:调整对比度后的一张或者多张图片
\end{itemize}
\subsection{adjust\_gamma}
\begin{lstlisting}[language=Python]
adjust_gamma(
image,
gamma=1,
gain=1)
\end{lstlisting}
在输入图片上执行Gamma修正，广为人知的Power Law Transform，函数根据方程$Out=In^gamma$变换输入图像像素之后缩放像素到0-1之间。
\begin{itemize}
\item 参数:image:一个Tensor。ganna：一个标量，非负实数，gain:一个标量,常量乘子。
\item[返回]：一个Tensor，Gamma修正后的输出。
\item[Raises]: ValueError:如果gamma是负数
\end{itemize}
注意：如果gamma大于1，直方图将向左移，输出图像将比输入图像暗。如果gamma小鱼1，直方图将向右移，输出图像将比输入图像亮。参考\href{http://en.wikipedia.org/wiki/Gamma_correction}{Gamma\_correction}
\subsection{adjust\_hug}
\begin{lstlisting}[language=Python]
adjust_hue(
    image,
    delta,
    name=None
)
\end{lstlisting}
调整RGB图像的色调。

这是一个很方便的转化RBG图像为浮点表达的方法，转化它为HSV，添加一些偏移到hue通道，转化回RGB变回原来的数据类型。如果一些调整被限制它智能的最小化冗余转化。

image是一个RGB图像。图像的色调通过转化图像为HSV通过delta旋转色调通道H。图像然后转化为RGB。delta必须是在[-1,1]

参数:
\begin{itemize}
		\item image:单张或者多张RGB图像，形状的最后一个元素必须是3
		\item delta:一个浮点数，如歌添加到色调通道
		\item name:操作的名字
		\item[Returns]:调整后的一张或者多张图像，和image有相同的DType 
\end{itemize}
\subsection{adjust\_saturation}
\begin{lstlisting}[language=Python]
adjust_saturation(
    image,
    saturation_factor,
    name=None
)
\end{lstlisting}
调整RGB图像的饱和度。

这是一个很方便的转化RGB图像为浮点表达的方法，转化为HSV，添加一个偏移到S通道，转化回RGB然后变回原来的数据类型。如果多个调整被限制它智能的最小化冗余转化的数量。

image是一个RGB图像，图像饱和度通过转化图像为HSV饭后S通道乘上saturation\_factor然后接企鹅。图像然后被转换为RGB。

参数:
\begin{itemize}
		\item image:一张或者多张RGB图像，形状最后一维的值必须是3
		\item saturation\_factor:浮点数，饱和度乘上的因子
		\item name:一个操作的名字
		\item[Returns]:调整后的一张或者多张形状和DType与image相同的的图像
\end{itemize}
\subsection{centrol\_crop}
\begin{lstlisting}[language=Python]
central_crop(
    image,
    central_fraction
)
\end{lstlisting}
剪裁图像的中心区域

移除图像的部分外围保留每个维度的中心区域，如果我们制定central\_fraction=0.5,这个函数返回一个如相面图中X表示区域
\begin{lstlisting}[language=Bash]
 --------
 |        |
 |  XXXX  |
 |  XXXX  |
 |        |   where "X" is the central 50% of the image.
  --------
\end{lstlisting}
参数:
\begin{itemize}
	\item imahe:三维浮点数，Tensor的形状[height，width,depth]
	\item central\_fraction:float(0,1],建材区域的比例
	\item[Raises] Value:如果central\_crop\_fraction不在(0,1]范围内。)
	\item[Returns]:3维浮点Tensor
\end{itemize}
\subsection{decode\_bmp}
\begin{lstlisting}[language=Python]
decode_bmp(
contens,
channels=None,
name 
)
\end{lstlisting}
解码BMP编码的图像为uint8的tensor，属性channels预示着解码后的图像的通道
接受下面值:
\begin{itemize}
		\item 0:用BMP编码图像的通道
		\item 3:输出RGB图像
		\item 4:输出RGBA图像
\end{itemize}
参数:
\begin{itemize}
		\item contents:一个string类型的Tensor。0维。BMO编码图像
		\item channels:一个int选项，默认为0
		\item name:操作的名字
		\item[输出]：类型为uint8类型的Tensor，形状为[height,width,channels],RGB顺序。
\end{itemize}
\subsection{tf.image.decode\_gif}
tf.image.decode\_gif(contents,name=None)
\begin{itemize}
\item contents:一个字符串Tensor，GIF编码的图像。
\item name:操作的名字。
\item 返回一个8位无符号的Tensor，四维形状为[num\_frames,height,width,3],通道顺序是RGB。
\end{itemize}
\subsection{tf.image.decode\_jpeg}
tf.image.decode\_jpeg(contents,channels=None,ratio=None,fancy\_upscaling=None,\newline
try\_recover\_truncated=None,acceptable\_fraction=None,dct\_metched=None,name=None)
解码JPEG编码的图像为无符号的8位整型tensor。\newline
\begin{itemize}
	\item contents:一个字符串tensor，JPEG编码的图像。
	\item channels:一个整数默认为，0代表编码图像的通道数（JPEG编码的图像），1代表灰度图，3带秒RGB图。
	\item radio:一个整数，默认为1,取值可以是1,2,4,8,表示缩减图像的比例。
	\item fancy\_upscaling:bool型，默认为True，表示用慢但是更好的提高色彩浓度。
	\item try\_recover\_truncated:bool型，默认是False，如果时True尝试从截断的输入恢复图像。
	\item acceptable\_fraction:float型，默认是1,可接受的最小的截断输入的因子。
	\item dct\_methed:string类型，默认为"".指定一个解压算法，默认是""由系统自行指定。可用的值有["INTEGER\_FAST","INTEGER\_ACCURATE"]
	\item name:操作的名字。
	\item 返回值为一个8位无符号整型Tensor，3维形状[height,width,channels]
\end{itemize}
\subsection{tf.image.encode\_jpeg}
tf.image.encode\_jpeg(image,format=None,quality=None,progressive=None,optimize\_size=None\newline
chroma\_downsampling=None,density\_uint=None,x\_density=None,y\_density=None,xmp\_metadata=None,name=None)
\begin{itemize}
	\item image:一个3维[height,width,chennels]，8位无符号整型Tensor。
	\item format:string类型，可以为"","grayscale","rgb",默认为""。如果format没有指定或者不为空字符串，默认格式从image的通道中选，1:输出灰度图，3:输出RGB图。
	\item quality:整型，默认值为95,代表压缩质量值[0,100],值越大越好，单速度越慢。
	\item optimize\_size:bool型,默认为False，如果为True用CPU/RAM减少尺寸同时保证质量。
	\item chroma\_downsampling:bool型，默认为True。
	\item density\_unit:一个字符串，可以为"in","cm",指定x\_density和y\_density.in每inch的像素，cm表示每厘米的像素。
	\item x\_density:一个整数，默认为300,每个density单位的水平像素。
	\item y\_density:一个整数，默认为6300,数值方向上每density单位的像素。
	\item xmp\_metadata:string类型,默认为"",如果为空，嵌入XMP metadata到图像头部。
	\item name:操作的名字。
	\item name：操作的名字。
	\item 返回0维字符串型JPED编码的Tensor。
\end{itemize}
\subsection{tf.image.decode\_png}
tf.image.decode\_png(contents,channels=None,dtype=None,name=None)
解码PNG编码的图像为8位或者16位无符号整型Tensor。
\begin{itemize}
	\item contents:一个0维PNG编码的图像的字符串的Tensor。
	\item chennels:整型默认为0,代表解码图像的通道,0用PNG编码图像数，1:代表输出灰度图像。3:代表输出RBG图像。4:输出RGBA图像。
	\item dtype:tf.DType,值可以为tf.uint8,tf.uint16,默认为tf.uint8。
	\item name:操作的名字。
	\item 返回3维[height,width,channels]的Tensor。

\end{itemize}
\subsection{tf.image.encode\_png}
tf.image.encode\_png(image,compression=None,name=None)
\begin{itemize}
	\item 一个8位或者16位的3维Tensor，形状为[height,width,channels]
	\item compression:一个整数，默认为-1,表示压缩等级。
	\item name:操作的名字。
	\item 返回一个0维string型的PNG-encoded的Tensor。
\end{itemize}
\subsection{tf.image.decode\_image}
tf.image.decode\_image(contents,channels=None,name=None)
\begin{itemize}
	\item contens:0维编码图像的字符串。
	\item channels:整数，默认为0,解码图像的通道数。
	\item name:操作的名字。
	\item 返回JPEG,PNG的8位无符号的形状为[height,width,num\_channels]，GIF文件的形状为[num\_frames,height,width,3]
	\item ValueError:通道数不正确。
\end{itemize}
\subsection{tf.image.resize\_images}
tf.image.resize\_images(images,size,method=ResizeMethed.BILINEAR,align\_corners=False)
\begin{itemize}
	\item images:形状为[batch,height,width,channels]4维Tensor或3维Tensor，形状为[height,width,channels]
	\item size:一维int32整型Tensor元素:new\_height,new\_width,新的图像尺寸。
	\item methed:ResizeMethod，默认为ResizeMethod.BILINEAR
		\begin{itemize}
			\item ResizeMethod.BILINEAR:二进制插值。
			\item ResizeMethod.NEAGREST\_NEIGHBOR:
			\item ResizeMethod.BICUBIC:
			\item ResizeMethod.AREA:
		\end{itemize}
	\item align\_corners:bool型，如果为真提取对齐四个角，默认为False。
	\item 异常
		\begin{itemize}
			\item ValueError:图像形状和函数要求的不一样。
			\item ValueError:size是不可以用的形状或者类型。
			\item ValueError:指定的方法不支持。
		\end{itemize}
	\item 如果图像时4维[batch,new\_height,new\_height,channels],如果图像是3维，形状为[new\_height,new\_width,channels]
\end{itemize}
