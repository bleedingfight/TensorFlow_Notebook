\section{为移动部署准备模型}
这要求你在训练过程中储模型信息和你想释放它作为移动app的一部分非常不同，这个张建包含从训练模型到产品释放的一些转化工具。
\subsection{保存的文件格式有什么不同？}
你可能发现tensorflow保存图的一些不同的方法变得非常的困惑。为了帮组理解，下面是一些不同组建的关于用于何处的介绍。目标通常被定义和序列化为protocol buffers:
\begin{itemize}
\item NodeDef:在模型中定义一个操作。他有一个独一无二的名字，一些其他节点的名字列表接收输入，才做类型实现(例如Add或者Mul)和任何需要控制操作的属性。这是TensorFlow基本的计算单元，所有网络节点的工作通过迭代被做，轮流使用每一个。这也许是一个单个的标量或者字符创，但是也保存一整个多为TensorFlow数组。Constent常熟的值被存在NodeDef，因此当序列化的时候大的常熟可能占据一些空间
\item Checkpoint。另一个通过使用variable操作存储模型值的方法。不想Const操作，这不存储他们的内容作为NodeDef的一部分，因此他们在GraphDef中占据非常小的空间。当计算的时候他们的值在RAM中保持，然后周期性的输出checkpoint文件到磁盘。这通常发生在神经网络被训练和权重被更新的时候，因此它是一个时间敏感的操作，也许发生在分布式的一些工作站上，因此文件格式必须快和灵活。他们存储作为多个checkpoint文件的一部分，结合checkpoint文件中的metadata文件描述c。当你通过API访问（例如传递一个文件名作为命令行参数）checkpoint文件，你见够用通常的前缀和文件关联。如果你有这些文件
\begin{lstlisting}[language=Bash]
/tmp/model/model-chkpt-1000.data-00000-of-00002
/tmp/model/model-chkpt-1000.data-00001-of-00002
/tmp/model/model-chkpt-1000.index
/tmp/model/model-chkpt-1000.meta
\end{lstlisting}
你讲访问他们作为/tmp/model/chkpt-1000
\item GraphDef:有一个NodeDefs列表，结合定义计算图执行。在训练中一些节点将为Variables，因此如果你想有一个完整的可运行的图，包含权重，你将需要调用恢复操作从checkpoint文件获取这些值。因为checkpoint载入必须灵活的处理所有的训练请求，这可能是一个在移动端和嵌入式设备实现的技巧，特别是想iOS没有合适的文件系统可用的情况。这里的手写脚本\href{https://www.github.com/tensorflow/tensorflow/blob/r1.4/tensorflow/python/tools/freeze_graph.py}{freeze\_graph.py}。正如上面提到的，仓鼠啊哦做存储他们的值错位NodeDef的有部分，因此如果所有的Variable权重被转化为常数节点。你可以在单次调用中载入结果文件不需要从checkpoint中回复变量值。一个查看GraphDef文件是有时候你已经存储在文本格式以方便查看。这个版本通常有.pbtxt文件后缀，正如二进制文件的.pb后缀一样
\item FunctionDefLibrary：在GraphDef出现，是搞笑的设置子图，关于输入输出的信息。每个子图可以用作主图的操作，运行简单的实例化不同的节点，用泪水的方式用其它语言包装代码
\item MetaGraphDef:一个空白的GraphDef仅仅有关于计算网络的信息，但是没有额外的关于魔性的信息或者模型如何使用的我信息。MetaGraphDef包含一个GraphDef定义模型的部分计算，而且包含想signatures的信息（暗示你想要调用的的输入输出，数据和Checkpoint文件存储地），对于一组操作方便的标签
\item SavedModel：通常享有不同版本的图依赖一些chechpoint的变量。例如，你也许在一张图上需要需要GPU和CPU版本为两者保存权重。你也许需要额外的文件(想标记文件)作为你的模型的一部分。SavedModel文件通过放你保存多版本的图不复制变量，也在同一个bundle存储assert文件处理这些需要。在hood下，用MetaGraphDef和checkpoint文件，沿着额外的metadata文件。如果你用TensorFlow Serving部署web API他的格式你将想用它。
\end{itemize}
